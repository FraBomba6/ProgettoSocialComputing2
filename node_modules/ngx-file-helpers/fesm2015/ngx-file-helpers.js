import { __awaiter, __decorate } from 'tslib';
import { EventEmitter, Input, Output, HostListener, Directive, ElementRef, Renderer2, NgModule } from '@angular/core';

class ReadFileImpl {
    constructor(_underlyingFile, _readMode, _content) {
        this._underlyingFile = _underlyingFile;
        this._readMode = _readMode;
        this._content = _content;
    }
    get name() {
        return this._underlyingFile.name;
    }
    get size() {
        return this._underlyingFile.size;
    }
    get type() {
        return this._underlyingFile.type;
    }
    get readMode() {
        return this._readMode;
    }
    get content() {
        return this._content;
    }
    get underlyingFile() {
        return this._underlyingFile;
    }
}

var ReadMode;
(function (ReadMode) {
    ReadMode[ReadMode["arrayBuffer"] = 0] = "arrayBuffer";
    ReadMode[ReadMode["binaryString"] = 1] = "binaryString";
    ReadMode[ReadMode["dataURL"] = 2] = "dataURL";
    ReadMode[ReadMode["text"] = 3] = "text";
})(ReadMode || (ReadMode = {}));

function coerceBooleanProperty(value) {
    return value != null && `${value}` !== 'false';
}
function readFileAsync(file, readMode) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const fileReader = event.target;
                const readFile = new ReadFileImpl(file, readMode, fileReader.result);
                resolve(readFile);
            };
            reader.onerror = (event) => {
                reject(event);
            };
            switch (readMode) {
                case ReadMode.arrayBuffer:
                    reader.readAsArrayBuffer(file);
                    break;
                case ReadMode.binaryString:
                    reader.readAsBinaryString(file);
                    break;
                case ReadMode.text:
                    reader.readAsText(file);
                    break;
                case ReadMode.dataURL:
                default:
                    reader.readAsDataURL(file);
                    break;
            }
        });
    });
}

class FileHandler {
    constructor() {
        this.filter = () => true;
        this.readStart = new EventEmitter();
        this.readEnd = new EventEmitter();
    }
    readFiles(files, onFileRead) {
        return __awaiter(this, void 0, void 0, function* () {
            const filteredFiles = Array.from(files).filter(this.filter);
            const fileCount = filteredFiles.length;
            this.readStart.emit(fileCount);
            yield Promise.all(filteredFiles.map((file) => __awaiter(this, void 0, void 0, function* () {
                const readFile = yield readFileAsync(file, this.readMode);
                onFileRead(readFile);
            })));
            this.readEnd.emit(fileCount);
        });
    }
}
__decorate([
    Input()
], FileHandler.prototype, "readMode", void 0);
__decorate([
    Input()
], FileHandler.prototype, "filter", void 0);
__decorate([
    Output()
], FileHandler.prototype, "readStart", void 0);
__decorate([
    Output()
], FileHandler.prototype, "readEnd", void 0);

let FileDropzoneDirective = class FileDropzoneDirective extends FileHandler {
    constructor() {
        super(...arguments);
        this.fileDrop = new EventEmitter();
    }
    onDragEnter(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    onDragOver(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    onDrop(event) {
        event.stopPropagation();
        event.preventDefault();
        this.readFiles(event.dataTransfer.files, readFile => this.fileDrop.emit(readFile));
    }
};
__decorate([
    Output()
], FileDropzoneDirective.prototype, "fileDrop", void 0);
__decorate([
    HostListener('dragenter', ['$event'])
], FileDropzoneDirective.prototype, "onDragEnter", null);
__decorate([
    HostListener('dragover', ['$event'])
], FileDropzoneDirective.prototype, "onDragOver", null);
__decorate([
    HostListener('drop', ['$event'])
], FileDropzoneDirective.prototype, "onDrop", null);
FileDropzoneDirective = __decorate([
    Directive({
        selector: '[ngxFileDropzone]',
        exportAs: 'ngxFileDropzone'
    })
], FileDropzoneDirective);

let FilePickerDirective = class FilePickerDirective extends FileHandler {
    constructor(el, renderer) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.accept = '';
        this.filePick = new EventEmitter();
    }
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = coerceBooleanProperty(value);
    }
    ngOnInit() {
        this._input = this.renderer.createElement('input');
        this.renderer.appendChild(this.el.nativeElement, this._input);
        this.renderer.setAttribute(this._input, 'type', 'file');
        this.renderer.setAttribute(this._input, 'accept', this.accept);
        this.renderer.setStyle(this._input, 'display', 'none');
        if (this.multiple) {
            this.renderer.setAttribute(this._input, 'multiple', 'multiple');
        }
        this.renderer.listen(this._input, 'change', (event) => this._onListen(event));
    }
    reset() {
        if (!this._input) {
            console.error('It seems that ngOnInit() has not been executed or that the hidden _input element is null. Did you mess with the DOM?');
            return;
        }
        this._input.value = null;
    }
    browse() {
        if (!this._input) {
            console.error('It seems that ngOnInit() has not been executed or that the hidden _input element is null. Did you mess with the DOM?');
            return;
        }
        this._input.click();
    }
    // The callback signature prevent the async/await usage
    _onListen(event) {
        const target = event.target;
        this.readFiles(target.files, readFile => this.filePick.emit(readFile))
            // reset value to trick change event making it changeable every time
            .finally(() => (target.value = ''));
    }
};
FilePickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input()
], FilePickerDirective.prototype, "accept", void 0);
__decorate([
    Input()
], FilePickerDirective.prototype, "multiple", null);
__decorate([
    Output()
], FilePickerDirective.prototype, "filePick", void 0);
__decorate([
    HostListener('click')
], FilePickerDirective.prototype, "browse", null);
FilePickerDirective = __decorate([
    Directive({
        selector: '[ngxFilePicker]',
        exportAs: 'ngxFilePicker'
    })
], FilePickerDirective);

let NgxFileHelpersModule = class NgxFileHelpersModule {
};
NgxFileHelpersModule = __decorate([
    NgModule({
        declarations: [FileDropzoneDirective, FilePickerDirective],
        imports: [],
        exports: [FileDropzoneDirective, FilePickerDirective]
    })
], NgxFileHelpersModule);

/*
 * Public API Surface of ngx-file-helpers
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FileDropzoneDirective, FilePickerDirective, NgxFileHelpersModule, ReadMode, FileHandler as Éµa };
//# sourceMappingURL=ngx-file-helpers.js.map
