import { __awaiter, __decorate } from 'tslib';
import { EventEmitter, Input, Output, HostListener, Directive, ElementRef, Renderer2, NgModule } from '@angular/core';

import * as ɵngcc0 from '@angular/core';
class ReadFileImpl {
    constructor(_underlyingFile, _readMode, _content) {
        this._underlyingFile = _underlyingFile;
        this._readMode = _readMode;
        this._content = _content;
    }
    get name() {
        return this._underlyingFile.name;
    }
    get size() {
        return this._underlyingFile.size;
    }
    get type() {
        return this._underlyingFile.type;
    }
    get readMode() {
        return this._readMode;
    }
    get content() {
        return this._content;
    }
    get underlyingFile() {
        return this._underlyingFile;
    }
}

var ReadMode;
(function (ReadMode) {
    ReadMode[ReadMode["arrayBuffer"] = 0] = "arrayBuffer";
    ReadMode[ReadMode["binaryString"] = 1] = "binaryString";
    ReadMode[ReadMode["dataURL"] = 2] = "dataURL";
    ReadMode[ReadMode["text"] = 3] = "text";
})(ReadMode || (ReadMode = {}));

function coerceBooleanProperty(value) {
    return value != null && `${value}` !== 'false';
}
function readFileAsync(file, readMode) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                const fileReader = event.target;
                const readFile = new ReadFileImpl(file, readMode, fileReader.result);
                resolve(readFile);
            };
            reader.onerror = (event) => {
                reject(event);
            };
            switch (readMode) {
                case ReadMode.arrayBuffer:
                    reader.readAsArrayBuffer(file);
                    break;
                case ReadMode.binaryString:
                    reader.readAsBinaryString(file);
                    break;
                case ReadMode.text:
                    reader.readAsText(file);
                    break;
                case ReadMode.dataURL:
                default:
                    reader.readAsDataURL(file);
                    break;
            }
        });
    });
}

class FileHandler {
    constructor() {
        this.filter = () => true;
        this.readStart = new EventEmitter();
        this.readEnd = new EventEmitter();
    }
    readFiles(files, onFileRead) {
        return __awaiter(this, void 0, void 0, function* () {
            const filteredFiles = Array.from(files).filter(this.filter);
            const fileCount = filteredFiles.length;
            this.readStart.emit(fileCount);
            yield Promise.all(filteredFiles.map((file) => __awaiter(this, void 0, void 0, function* () {
                const readFile = yield readFileAsync(file, this.readMode);
                onFileRead(readFile);
            })));
            this.readEnd.emit(fileCount);
        });
    }
}
FileHandler.ɵfac = function FileHandler_Factory(t) { return new (t || FileHandler)(); };
FileHandler.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileHandler, inputs: { filter: "filter", readMode: "readMode" }, outputs: { readStart: "readStart", readEnd: "readEnd" } });
__decorate([
    Input()
], FileHandler.prototype, "readMode", void 0);
__decorate([
    Input()
], FileHandler.prototype, "filter", void 0);
__decorate([
    Output()
], FileHandler.prototype, "readStart", void 0);
__decorate([
    Output()
], FileHandler.prototype, "readEnd", void 0);

let FileDropzoneDirective = class FileDropzoneDirective extends FileHandler {
    constructor() {
        super(...arguments);
        this.fileDrop = new EventEmitter();
    }
    onDragEnter(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    onDragOver(event) {
        event.stopPropagation();
        event.preventDefault();
    }
    onDrop(event) {
        event.stopPropagation();
        event.preventDefault();
        this.readFiles(event.dataTransfer.files, readFile => this.fileDrop.emit(readFile));
    }
};
FileDropzoneDirective.ɵfac = function FileDropzoneDirective_Factory(t) { return ɵFileDropzoneDirective_BaseFactory(t || FileDropzoneDirective); };
FileDropzoneDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FileDropzoneDirective, selectors: [["", "ngxFileDropzone", ""]], hostBindings: function FileDropzoneDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dragenter", function FileDropzoneDirective_dragenter_HostBindingHandler($event) { return ctx.onDragEnter($event); })("dragover", function FileDropzoneDirective_dragover_HostBindingHandler($event) { return ctx.onDragOver($event); })("drop", function FileDropzoneDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, outputs: { fileDrop: "fileDrop" }, exportAs: ["ngxFileDropzone"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Output()
], FileDropzoneDirective.prototype, "fileDrop", void 0);
__decorate([
    HostListener('dragenter', ['$event'])
], FileDropzoneDirective.prototype, "onDragEnter", null);
__decorate([
    HostListener('dragover', ['$event'])
], FileDropzoneDirective.prototype, "onDragOver", null);
__decorate([
    HostListener('drop', ['$event'])
], FileDropzoneDirective.prototype, "onDrop", null);

let FilePickerDirective = class FilePickerDirective extends FileHandler {
    constructor(el, renderer) {
        super();
        this.el = el;
        this.renderer = renderer;
        this.accept = '';
        this.filePick = new EventEmitter();
    }
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = coerceBooleanProperty(value);
    }
    ngOnInit() {
        this._input = this.renderer.createElement('input');
        this.renderer.appendChild(this.el.nativeElement, this._input);
        this.renderer.setAttribute(this._input, 'type', 'file');
        this.renderer.setAttribute(this._input, 'accept', this.accept);
        this.renderer.setStyle(this._input, 'display', 'none');
        if (this.multiple) {
            this.renderer.setAttribute(this._input, 'multiple', 'multiple');
        }
        this.renderer.listen(this._input, 'change', (event) => this._onListen(event));
    }
    reset() {
        if (!this._input) {
            console.error('It seems that ngOnInit() has not been executed or that the hidden _input element is null. Did you mess with the DOM?');
            return;
        }
        this._input.value = null;
    }
    browse() {
        if (!this._input) {
            console.error('It seems that ngOnInit() has not been executed or that the hidden _input element is null. Did you mess with the DOM?');
            return;
        }
        this._input.click();
    }
    // The callback signature prevent the async/await usage
    _onListen(event) {
        const target = event.target;
        this.readFiles(target.files, readFile => this.filePick.emit(readFile))
            // reset value to trick change event making it changeable every time
            .finally(() => (target.value = ''));
    }
};
FilePickerDirective.ɵfac = function FilePickerDirective_Factory(t) { return new (t || FilePickerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
FilePickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FilePickerDirective, selectors: [["", "ngxFilePicker", ""]], hostBindings: function FilePickerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FilePickerDirective_click_HostBindingHandler() { return ctx.browse(); });
    } }, inputs: { accept: "accept", multiple: "multiple" }, outputs: { filePick: "filePick" }, exportAs: ["ngxFilePicker"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
FilePickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input()
], FilePickerDirective.prototype, "accept", void 0);
__decorate([
    Input()
], FilePickerDirective.prototype, "multiple", null);
__decorate([
    Output()
], FilePickerDirective.prototype, "filePick", void 0);
__decorate([
    HostListener('click')
], FilePickerDirective.prototype, "browse", null);

let NgxFileHelpersModule = class NgxFileHelpersModule {
};
NgxFileHelpersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxFileHelpersModule });
NgxFileHelpersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxFileHelpersModule_Factory(t) { return new (t || NgxFileHelpersModule)(); }, imports: [[]] });

const ɵFileDropzoneDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(FileDropzoneDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FileDropzoneDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxFileDropzone]',
                exportAs: 'ngxFileDropzone'
            }]
    }], null, { fileDrop: [{
            type: Output
        }], onDragEnter: [{
            type: HostListener,
            args: ['dragenter', ['$event']]
        }], onDragOver: [{
            type: HostListener,
            args: ['dragover', ['$event']]
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FilePickerDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxFilePicker]',
                exportAs: 'ngxFilePicker'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { accept: [{
            type: Input
        }], filePick: [{
            type: Output
        }], multiple: [{
            type: Input
        }], browse: [{
            type: HostListener,
            args: ['click']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxFileHelpersModule, { declarations: [FileDropzoneDirective, FilePickerDirective], exports: [FileDropzoneDirective, FilePickerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxFileHelpersModule, [{
        type: NgModule,
        args: [{
                declarations: [FileDropzoneDirective, FilePickerDirective],
                imports: [],
                exports: [FileDropzoneDirective, FilePickerDirective]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-file-helpers
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FileDropzoneDirective, FilePickerDirective, NgxFileHelpersModule, ReadMode, FileHandler as ɵa };

//# sourceMappingURL=ngx-file-helpers.js.map